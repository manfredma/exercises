:toc:

== 一、spring boot 启动过程

=== 1.1 SpringApplication#run

SpringApplication#run 方法等同于 new SpringApplication(primarySources).run(args)

==== 1.1.1 new SpringApplication 过程

----
    public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {
		// 这个字段一般为空
        this.resourceLoader = resourceLoader;
		Assert.notNull(primarySources, "PrimarySources must not be null");
		// 主资源类（一般就是启动类，即 SpringApplication#run 的参数）
		this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));
        // 推断 WEB 类型（通过类路径上是否有对应的类来进行判断）
        // 例如存在 org.springframework.web.reactive.DispatcherHandler，则认为是 REACTIVE 类型
		this.webApplicationType = WebApplicationType.deduceFromClasspath();
        // 通过 spring.factories 机制加载 Bootstrapper
		this.bootstrappers = new ArrayList<>(getSpringFactoriesInstances(Bootstrapper.class));
        // 通过 spring.factories 机制加载 ApplicationContextInitializer
		setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
        // 通过 spring.factories 机制加载 ApplicationListener
		setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
        // 通过堆栈中调用 main 方法的类推到出来
		this.mainApplicationClass = deduceMainApplicationClass();
	}
----

==== 1.1.2 Bootstrapper 引导程序

[%hardbreaks]
主要接口：
org.springframework.boot.Bootstrapper
org.springframework.boot.BootstrapRegistry

功能 +
通过下面的描述来看，主要是用来在spring上下文初始化前需要初始化的类。分析到后面的初始化流程的时候可以再观察一下。

________
A simple object registry that is available during startup and Environment post-processing up to the point that the ApplicationContext is prepared.
Can be used to register instances that may be expensive to create, or need to be shared before the ApplicationContext is available.
The registry uses Class as a key, meaning that only a single instance of a given type can be stored.
________

其生命周期仅存在于 spring 初始化阶段（refresh 前关闭），非对用户开放的 API！

==== 1.1.3 ApplicationContextInitializer 初始化

通过下面的描述来看，主要是提供了一个在 spring context refreshed 之前的回调接口，即：spring 会在上下文真正初始化之前进行调用。

________
Callback interface for initializing a Spring ConfigurableApplicationContext prior to being refreshed.
Typically used within web applications that require some programmatic initialization of the application context.
For example, registering property sources or activating profiles against the context's environment.
See ContextLoader and FrameworkServlet support for declaring a "contextInitializerClasses" context-param and init-param, respectively.
ApplicationContextInitializer processors are encouraged to detect whether Spring's Ordered interface has been implemented or if the @Order annotation is present and to sort instances accordingly if so prior to invocation.
________

image::img/application_context_initializer实现类.png[application_context_initializer实现类]

上图中是典型的一些实现类。

----

/**
 * {@link ApplicationContextInitializer} for setting the servlet context.
 *
 * @author Dave Syer
 * @author Phillip Webb
 * @since 2.0.0
 */
public class ServletContextApplicationContextInitializer
		implements ApplicationContextInitializer<ConfigurableWebApplicationContext>, Ordered {

	private int order = Ordered.HIGHEST_PRECEDENCE;

	private final ServletContext servletContext;

	private final boolean addApplicationContextAttribute;

    // 这个的初始化一般和 ServletContainerInitializer 配合使用，由WEB容器回调 ServletContainerInitializer，则可以获取 ServletContext
	/**
	 * Create a new {@link ServletContextApplicationContextInitializer} instance.
	 * @param servletContext the servlet that should be ultimately set.
	 */
	public ServletContextApplicationContextInitializer(ServletContext servletContext) {
		this(servletContext, false);
	}

	/**
	 * Create a new {@link ServletContextApplicationContextInitializer} instance.
	 * @param servletContext the servlet that should be ultimately set.
	 * @param addApplicationContextAttribute if the {@link ApplicationContext} should be
	 * stored as an attribute in the {@link ServletContext}
	 * @since 1.3.4
	 */
	public ServletContextApplicationContextInitializer(ServletContext servletContext,
			boolean addApplicationContextAttribute) {
		this.servletContext = servletContext;
		this.addApplicationContextAttribute = addApplicationContextAttribute;
	}

	public void setOrder(int order) {
		this.order = order;
	}

	@Override
	public int getOrder() {
		return this.order;
	}

    // 将 applicationContext 和 servletContext 关联起来，这样两个上下文就可以互相访问了。
	@Override
	public void initialize(ConfigurableWebApplicationContext applicationContext) {
		applicationContext.setServletContext(this.servletContext);
		if (this.addApplicationContextAttribute) {
			this.servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE,
					applicationContext);
		}

	}

}

public interface ServletContainerInitializer {

    /**
     * Receives notification during startup of a web application of the classes
     * within the web application that matched the criteria defined via the
     * {@link javax.servlet.annotation.HandlesTypes} annotation.
     *
     * @param c     The (possibly null) set of classes that met the specified
     *              criteria
     * @param ctx   The ServletContext of the web application in which the
     *              classes were discovered
     *
     * @throws ServletException If an error occurs
     */
    void onStartup(Set<Class<?>> c, ServletContext ctx) throws ServletException;
}
----

这个功能的加载整体还是通过 spring.factories 机制进行加载。其中 spring.boot 中默认生效的如下： 上面提到的ServletContextApplicationContextInitializer需要根据是否是WEB环境来动态判断是否启动，与这些静态的稍微不同。

----
# Application Context Initializers
org.springframework.context.ApplicationContextInitializer=\
org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\
org.springframework.boot.context.ContextIdApplicationContextInitializer,\
org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\
org.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer,\
org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer
----

1. ConfigurationWarningsApplicationContextInitializer +
其主要是通过 BeanDefinitionRegistryPostProcessor 增加了检测，当前只检测了扫描路径
* 扫描配置了有问题的路径，目前检测了org.springframework、org 两个包路径。目前主要写警告日志，不会发生阻断。
2. ContextIdApplicationContextInitializer +
其主要功能是创建一下Spring上下文的ContextId。
3. DelegatingApplicationContextInitializer +
通过属性 context.initializer.classes 加载其他的ApplicationContextInitializer，相当于提供了另外一种加载ApplicationContextInitializer的扩展方式。
4. RSocketPortInfoApplicationContextInitializer +
注册 RSocketServerInitializedEvent 的 ApplicationListener，感知 RSocketServer 端口设置到属性 server.ports 中。
5. ServerPortInfoApplicationContextInitializer +
注册 WebServerInitializedEvent 的 ApplicationListener，感知 WEB 的端口设置到属性 server.ports 中。

==== 1.1.4 ApplicationListener 初始化

ApplicationListener 主要是监听 ApplicationEvent 来做出响应，是观察者模式。其回调机制依赖于对应事件的发生。

----
/**
 * Interface to be implemented by application event listeners.
 *
 * <p>Based on the standard {@code java.util.EventListener} interface
 * for the Observer design pattern.
 *
 * <p>As of Spring 3.0, an {@code ApplicationListener} can generically declare
 * the event type that it is interested in. When registered with a Spring
 * {@code ApplicationContext}, events will be filtered accordingly, with the
 * listener getting invoked for matching event objects only.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @param <E> the specific {@code ApplicationEvent} subclass to listen to
 * @see org.springframework.context.ApplicationEvent
 * @see org.springframework.context.event.ApplicationEventMulticaster
 * @see org.springframework.context.event.SmartApplicationListener
 * @see org.springframework.context.event.GenericApplicationListener
 * @see org.springframework.context.event.EventListener
 */
@FunctionalInterface
public interface ApplicationListener<E extends ApplicationEvent> extends EventListener {

	/**
	 * Handle an application event.
	 * @param event the event to respond to
	 */
	void onApplicationEvent(E event);


	/**
	 * Create a new {@code ApplicationListener} for the given payload consumer.
	 * @param consumer the event payload consumer
	 * @param <T> the type of the event payload
	 * @return a corresponding {@code ApplicationListener} instance
	 * @since 5.3
	 * @see PayloadApplicationEvent
	 */
	static <T> ApplicationListener<PayloadApplicationEvent<T>> forPayload(Consumer<T> consumer) {
		return event -> consumer.accept(event.getPayload());
	}

}
----

ApplicationListener （springboot 中默认加载的 ApplicationListener）

----
# Application Listeners
org.springframework.context.ApplicationListener=\
org.springframework.boot.ClearCachesApplicationListener,\
org.springframework.boot.builder.ParentContextCloserApplicationListener,\
org.springframework.boot.context.FileEncodingApplicationListener,\
org.springframework.boot.context.config.AnsiOutputApplicationListener,\
org.springframework.boot.context.config.DelegatingApplicationListener,\
org.springframework.boot.context.logging.LoggingApplicationListener,\
org.springframework.boot.env.EnvironmentPostProcessorApplicationListener,\
org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener
----

1. ClearCachesApplicationListener +
关注事件类型：ContextRefreshedEvent +
功能：清空反射的缓存、清空 classloader 的缓存(需要 classloader 实现 clearCache 方法)
2. ParentContextCloserApplicationListener +
监听事件类型：ParentContextAvailableEvent +
功能：在父类上下文中新注册一个监听器 ContextCloserListener （关注事件类型：ContextClosedEvent），这样当父上下文关闭的时候，也关闭一下当前上下文。
3. FileEncodingApplicationListener +
监听事件类型：ApplicationEnvironmentPreparedEvent +
功能：如果配置了 spring.mandatory-file-encoding 环境属性（自定义），则要求系统属性 file.encoding 与 spring.mandatory-file-encoding 的值相同！
4. AnsiOutputApplicationListener +
监听事件类型：ApplicationEnvironmentPreparedEvent +
功能：设置 AnsiOutput 的属性值
5. DelegatingApplicationListener +
监听事件类型: ApplicationEnvironmentPreparedEvent & ApplicationEvent +
功能: +
* 监听 ApplicationEnvironmentPreparedEvent，主要是根据属性 context.listener.classes 来加载自定义的 ApplicationListener
* 监听 ApplicationEvent，主要是将事件发送给上面加载的自定义的 ApplicationListener
6. LoggingApplicationListener +
监听事件类型： +
ApplicationStartingEvent +
ApplicationEnvironmentPreparedEvent +
ApplicationPreparedEvent +
ContextClosedEvent +
ApplicationFailedEvent +
功能：其主要监听的上下文生命周期的事件类型，联动处理 loggingSystem 的生命周期；
7. EnvironmentPostProcessorApplicationListener +
监听事件类型： +
ApplicationEnvironmentPreparedEvent +
ApplicationPreparedEvent +
ApplicationFailedEvent +
功能：+ 其主要监听的上下文生命周期的事件类型，联动调用 EnvironmentPostProcessor（EnvironmentPostProcessor 从 ConfigurableBootstrapContext 获取）；
8. LiquibaseServiceLocatorApplicationListener +
监听事件类型：ApplicationStartingEvent +
功能：执行 Liquibase 相关操作（通过判断类路径上是否存在 liquibase.servicelocator.CustomResolverServiceLocator 来决定是否启用）

== 二、META-INF/spring.factories 扩展机制

* 在 springboot 启动的过程中，会加载类路径中 META-INF/spring.factories 文件。 加载实现在 spring-core 模块的 org.springframework.core.io.support.SpringFactoriesLoader
* 文件格式 类名=实现类1,实现类2...

----
# Logging Systems
org.springframework.boot.logging.LoggingSystemFactory=\
org.springframework.boot.logging.logback.LogbackLoggingSystem.Factory,\
org.springframework.boot.logging.log4j2.Log4J2LoggingSystem.Factory,\
org.springframework.boot.logging.java.JavaLoggingSystem.Factory
----

== 三、参考