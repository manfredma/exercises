

Kent Beck 给出的答案是：软件设计是为了在让软件在长期范围内容易应对变化。 在这个精炼的定义中，包含着三个关键词：长期，容易，变化。这意味着:

1. 越是需要长期维护的项目，变化更多，也更难预测变化的方式 ;
2. 软件设计，事关成本 ;
3. 如何在难以预测的千变万化中，保持低廉的变更成本，正是软件设计要解决的问题。 +

对此，Kent Beck 提出了一个更为精炼的原则：局部化影响。意思是说：我们希望，任何一个变化，对于我们当前的软件设计影响范围都可以控制在一个尽量小的局部。

所谓内聚性，关注的是一个软件单位内部的关联紧密程度。因而高内聚追求的是关联紧密的事物应该被放在一起，并且只有关联紧密的事物才应该被放在一起。简单说，就是Unix的设计哲学：Do One Thing, Do It Well。
而耦合性，则是强调两个或多个软件单位之间的关联紧密程度。因而低耦合追求的是，软件单位之间尽可能不要相互影响。

一旦人们开始进行进行模块化拆分，就必须解决如下两个问题:

究竟软件模块该怎样划分才是合理的?

将一个大单元划分为多个小单元之后，它们之间必然要通过衔接点进行合作。如果我们把这些衔接点看作 API，那么问题就变为：怎样定义 API 才是合理的?





我们之前已经讨论过，所谓高内聚，指的是关联紧密的事物应该被放在一起。没有比两段完全相同的代码关联更为紧密。因而重复代码意味着低内聚。

而更为糟糕的是，本质重复的代码，其实都在表达（即依赖）同一项知识。如果它们表达（即依赖）的知识发生了变化，这些重复的代码统统都要修改。因而, 重复代码也意味着高耦合。

== 参考
[%hardbreaks]
https://www.infoq.cn/article/change-driven-orthogonal-design[变化驱动：正交设计]
https://www.jianshu.com/p/a95f67ed714d[实战正交设计]